'use strict';

(function () {

	/*exported commons */
	var commons = {};

	var aria = commons.aria = {},
	    lookupTables = aria._lut = {};

	lookupTables.attributes = {
		'aria-activedescendant': {
			type: 'idref'
		},
		'aria-atomic': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-autocomplete': {
			type: 'nmtoken',
			values: ['inline', 'list', 'both', 'none']
		},
		'aria-busy': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-checked': {
			type: 'nmtoken',
			values: ['true', 'false', 'mixed', 'undefined']
		},
		'aria-colcount': {
			type: 'int'
		},
		'aria-colindex': {
			type: 'int'
		},
		'aria-colspan': {
			type: 'int'
		},
		'aria-controls': {
			type: 'idrefs'
		},
		'aria-describedby': {
			type: 'idrefs'
		},
		'aria-disabled': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-dropeffect': {
			type: 'nmtokens',
			values: ['copy', 'move', 'reference', 'execute', 'popup', 'none']
		},
		'aria-expanded': {
			type: 'nmtoken',
			values: ['true', 'false', 'undefined']
		},
		'aria-flowto': {
			type: 'idrefs'
		},
		'aria-grabbed': {
			type: 'nmtoken',
			values: ['true', 'false', 'undefined']
		},
		'aria-haspopup': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-hidden': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-invalid': {
			type: 'nmtoken',
			values: ['true', 'false', 'spelling', 'grammar']
		},
		'aria-label': {
			type: 'string'
		},
		'aria-labelledby': {
			type: 'idrefs'
		},
		'aria-level': {
			type: 'int'
		},
		'aria-live': {
			type: 'nmtoken',
			values: ['off', 'polite', 'assertive']
		},
		'aria-multiline': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-multiselectable': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-orientation': {
			type: 'nmtoken',
			values: ['horizontal', 'vertical']
		},
		'aria-owns': {
			type: 'idrefs'
		},
		'aria-posinset': {
			type: 'int'
		},
		'aria-pressed': {
			type: 'nmtoken',
			values: ['true', 'false', 'mixed', 'undefined']
		},
		'aria-readonly': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-relevant': {
			type: 'nmtokens',
			values: ['additions', 'removals', 'text', 'all']
		},
		'aria-required': {
			type: 'boolean',
			values: ['true', 'false']
		},
		'aria-rowcount': {
			type: 'int'
		},
		'aria-rowindex': {
			type: 'int'
		},
		'aria-rowspan': {
			type: 'int'
		},
		'aria-selected': {
			type: 'nmtoken',
			values: ['true', 'false', 'undefined']
		},
		'aria-setsize': {
			type: 'int'
		},
		'aria-sort': {
			type: 'nmtoken',
			values: ['ascending', 'descending', 'other', 'none']
		},
		'aria-valuemax': {
			type: 'decimal'
		},
		'aria-valuemin': {
			type: 'decimal'
		},
		'aria-valuenow': {
			type: 'decimal'
		},
		'aria-valuetext': {
			type: 'string'
		}
	};

	lookupTables.globalAttributes = ['aria-atomic', 'aria-busy', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-dropeffect', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-live', 'aria-owns', 'aria-relevant'];

	lookupTables.role = {
		'alert': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'alertdialog': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'application': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'article': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['article']
		},
		'banner': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'button': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded', 'aria-pressed']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null,
			implicit: ['button', 'input[type="button"]', 'input[type="image"]']
		},
		'cell': {
			type: 'structure',
			attributes: {
				allowed: ['aria-colindex', 'aria-colspan', 'aria-rowindex', 'aria-rowspan']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['row']
		},
		'checkbox': {
			type: 'widget',
			attributes: {
				required: ['aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null,
			implicit: ['input[type="checkbox"]']
		},
		'columnheader': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded', 'aria-sort', 'aria-readonly', 'aria-selected', 'aria-required']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['row']
		},
		'combobox': {
			type: 'composite',
			attributes: {
				required: ['aria-expanded'],
				allowed: ['aria-autocomplete', 'aria-required', 'aria-activedescendant']
			},
			owned: {
				all: ['listbox', 'textbox']
			},
			nameFrom: ['author'],
			context: null
		},
		'command': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'complementary': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['aside']
		},
		'composite': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'contentinfo': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'definition': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'dialog': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['dialog']
		},
		'directory': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null
		},
		'document': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['body']
		},
		'form': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'grid': {
			type: 'composite',
			attributes: {
				allowed: ['aria-level', 'aria-multiselectable', 'aria-readonly', 'aria-activedescendant', 'aria-expanded']
			},
			owned: {
				one: ['rowgroup', 'row']
			},
			nameFrom: ['author'],
			context: null
		},
		'gridcell': {
			type: 'widget',
			attributes: {
				allowed: ['aria-selected', 'aria-readonly', 'aria-expanded', 'aria-required']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['row']
		},
		'group': {
			type: 'structure',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['details']
		},
		'heading': {
			type: 'structure',
			attributes: {
				allowed: ['aria-level', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null,
			implicit: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']
		},
		'img': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['img']
		},
		'input': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'landmark': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'link': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null,
			implicit: ['a[href]']
		},
		'list': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: {
				all: ['listitem']
			},
			nameFrom: ['author'],
			context: null,
			implicit: ['ol', 'ul']
		},
		'listbox': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-multiselectable', 'aria-required', 'aria-expanded']
			},
			owned: {
				all: ['option']
			},
			nameFrom: ['author'],
			context: null,
			implicit: ['select']
		},
		'listitem': {
			type: 'structure',
			attributes: {
				allowed: ['aria-level', 'aria-posinset', 'aria-setsize', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['list'],
			implicit: ['li']
		},
		'log': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'main': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'marquee': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'math': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'menu': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded']
			},
			owned: {
				one: ['menuitem', 'menuitemradio', 'menuitemcheckbox']
			},
			nameFrom: ['author'],
			context: null
		},
		'menubar': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'menuitem': {
			type: 'widget',
			attributes: null,
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['menu', 'menubar']
		},
		'menuitemcheckbox': {
			type: 'widget',
			attributes: {
				required: ['aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['menu', 'menubar']
		},
		'menuitemradio': {
			type: 'widget',
			attributes: {
				allowed: ['aria-selected', 'aria-posinset', 'aria-setsize'],
				required: ['aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['menu', 'menubar']
		},
		'navigation': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'none': {
			type: 'structure',
			attributes: null,
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'note': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'option': {
			type: 'widget',
			attributes: {
				allowed: ['aria-selected', 'aria-posinset', 'aria-setsize', 'aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['listbox']
		},
		'presentation': {
			type: 'structure',
			attributes: null,
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'progressbar': {
			type: 'widget',
			attributes: {
				allowed: ['aria-valuetext', 'aria-valuenow', 'aria-valuemax', 'aria-valuemin']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'radio': {
			type: 'widget',
			attributes: {
				allowed: ['aria-selected', 'aria-posinset', 'aria-setsize'],
				required: ['aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null,
			implicit: ['input[type="radio"]']
		},
		'radiogroup': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-required', 'aria-expanded']
			},
			owned: {
				all: ['radio']
			},
			nameFrom: ['author'],
			context: null
		},
		'range': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'region': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['section']
		},
		'roletype': {
			type: 'abstract'
		},
		'row': {
			type: 'structure',
			attributes: {
				allowed: ['aria-level', 'aria-selected', 'aria-activedescendant', 'aria-expanded']
			},
			owned: {
				one: ['cell', 'columnheader', 'rowheader', 'gridcell']
			},
			nameFrom: ['author', 'contents'],
			context: ['rowgroup', 'grid', 'treegrid', 'table']
		},
		'rowgroup': {
			type: 'structure',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded']
			},
			owned: {
				all: ['row']
			},
			nameFrom: ['author', 'contents'],
			context: ['grid', 'table']
		},
		'rowheader': {
			type: 'structure',
			attributes: {
				allowed: ['aria-sort', 'aria-required', 'aria-readonly', 'aria-expanded', 'aria-selected']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['row']
		},
		'scrollbar': {
			type: 'widget',
			attributes: {
				required: ['aria-controls', 'aria-orientation', 'aria-valuenow', 'aria-valuemax', 'aria-valuemin'],
				allowed: ['aria-valuetext']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'search': {
			type: 'landmark',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'searchbox': {
			type: 'widget',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-autocomplete', 'aria-multiline', 'aria-readonly', 'aria-required']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['input[type="search"]']
		},
		'section': {
			nameFrom: ['author', 'contents'],
			type: 'abstract'
		},
		'sectionhead': {
			nameFrom: ['author', 'contents'],
			type: 'abstract'
		},
		'select': {
			nameFrom: ['author'],
			type: 'abstract'
		},
		'separator': {
			type: 'structure',
			attributes: {
				allowed: ['aria-expanded', 'aria-orientation']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'slider': {
			type: 'widget',
			attributes: {
				allowed: ['aria-valuetext', 'aria-orientation'],
				required: ['aria-valuenow', 'aria-valuemax', 'aria-valuemin']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'spinbutton': {
			type: 'widget',
			attributes: {
				allowed: ['aria-valuetext', 'aria-required'],
				required: ['aria-valuenow', 'aria-valuemax', 'aria-valuemin']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'status': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['output']
		},
		'structure': {
			type: 'abstract'
		},
		'switch': {
			type: 'widget',
			attributes: {
				required: ['aria-checked']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null
		},
		'tab': {
			type: 'widget',
			attributes: {
				allowed: ['aria-selected', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['tablist']
		},
		'table': {
			type: 'structure',
			attributes: {
				allowed: ['aria-colcount', 'aria-rowcount']
			},
			owned: {
				one: ['rowgroup', 'row']
			},
			nameFrom: ['author'],
			context: null,
			implicit: ['table']
		},
		'tablist': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded', 'aria-level', 'aria-multiselectable']
			},
			owned: {
				all: ['tab']
			},
			nameFrom: ['author'],
			context: null
		},
		'tabpanel': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'text': {
			type: 'structure',
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null
		},
		'textbox': {
			type: 'widget',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-autocomplete', 'aria-multiline', 'aria-readonly', 'aria-required']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['input[type="text"]', 'input:not([type])']
		},
		'timer': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null
		},
		'toolbar': {
			type: 'structure',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded']
			},
			owned: null,
			nameFrom: ['author'],
			context: null,
			implicit: ['menu[type="toolbar"]']
		},
		'tooltip': {
			type: 'widget',
			attributes: {
				allowed: ['aria-expanded']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: null
		},
		'tree': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-multiselectable', 'aria-required', 'aria-expanded']
			},
			owned: {
				all: ['treeitem']
			},
			nameFrom: ['author'],
			context: null
		},
		'treegrid': {
			type: 'composite',
			attributes: {
				allowed: ['aria-activedescendant', 'aria-expanded', 'aria-level', 'aria-multiselectable', 'aria-readonly', 'aria-required']
			},
			owned: {
				all: ['treeitem']
			},
			nameFrom: ['author'],
			context: null
		},
		'treeitem': {
			type: 'widget',
			attributes: {
				allowed: ['aria-checked', 'aria-selected', 'aria-expanded', 'aria-level', 'aria-posinset', 'aria-setsize']
			},
			owned: null,
			nameFrom: ['author', 'contents'],
			context: ['treegrid', 'tree']
		},
		'widget': {
			type: 'abstract'
		},
		'window': {
			nameFrom: ['author'],
			type: 'abstract'
		}
	};

	var color = {};
	commons.color = color;

	/*exported dom */
	var dom = commons.dom = {};

	/*exported table */
	var table = commons.table = {};

	/*exported text */
	var text = commons.text = {};
	/*exported utils */
	/*global axe */
	var utils = commons.utils = axe.utils;

	/*global aria, axe, lookupTables */

	/**
  * Get required attributes for a given role
  * @param  {String} role The role to check
  * @return {Array}
  */
	aria.requiredAttr = function (role) {
		'use strict';

		var roles = lookupTables.role[role],
		    attr = roles && roles.attributes && roles.attributes.required;
		return attr || [];
	};

	/**
  * Get allowed attributes for a given role
  * @param  {String} role The role to check
  * @return {Array}
  */
	aria.allowedAttr = function (role) {
		'use strict';

		var roles = lookupTables.role[role],
		    attr = roles && roles.attributes && roles.attributes.allowed || [],
		    requiredAttr = roles && roles.attributes && roles.attributes.required || [];
		return attr.concat(lookupTables.globalAttributes).concat(requiredAttr);
	};

	/**
  * Check if an aria- attribute name is valid
  * @param  {String} att The attribute name
  * @return {Boolean}
  */
	aria.validateAttr = function (att) {
		'use strict';

		return !!lookupTables.attributes[att];
	};

	/**
  * Validate the value of an ARIA attribute
  * @param  {HTMLElement} node The element to check
  * @param  {String} attr The name of the attribute
  * @return {Boolean}
  */
	aria.validateAttrValue = function (node, attr) {
		//jshint maxcomplexity: 12
		'use strict';

		var matches,
		    list,
		    doc = document,
		    value = node.getAttribute(attr),
		    attrInfo = lookupTables.attributes[attr];

		if (!attrInfo) {
			return true;
		}

		switch (attrInfo.type) {
			case 'boolean':
			case 'nmtoken':
				return typeof value === 'string' && attrInfo.values.indexOf(value.toLowerCase()) !== -1;

			case 'nmtokens':
				list = axe.utils.tokenList(value);
				// Check if any value isn't in the list of values
				return list.reduce(function (result, token) {
					return result && attrInfo.values.indexOf(token) !== -1;
					// Initial state, fail if the list is empty
				}, list.length !== 0);

			case 'idref':
				return !!(value && doc.getElementById(value));

			case 'idrefs':
				list = axe.utils.tokenList(value);
				// Check if any value isn't in the list of values
				return list.reduce(function (result, token) {
					return !!(result && doc.getElementById(token));
					// Initial state, fail if the list is empty
				}, list.length !== 0);

			case 'string':
				// anything goes
				return true;

			case 'decimal':
				matches = value.match(/^[-+]?([0-9]*)\.?([0-9]*)$/);
				return !!(matches && (matches[1] || matches[2]));

			case 'int':
				return (/^[-+]?[0-9]+$/.test(value)
				);
		}
	};

	/*global aria, dom, text */
	/**
  * Gets the accessible ARIA label text of a given element
  * @see http://www.w3.org/WAI/PF/aria/roles#namecalculation
  * @param  {HTMLElement} node The element to test
  * @return {Mixed}      String of visible text, or `null` if no label is found
  */
	aria.label = function (node) {
		var ref, candidate;

		if (node.getAttribute('aria-labelledby')) {
			// aria-labelledby
			ref = dom.idrefs(node, 'aria-labelledby');
			candidate = ref.map(function (thing) {
				return thing ? text.visible(thing, true) : '';
			}).join(' ').trim();

			if (candidate) {
				return candidate;
			}
		}

		// aria-label
		candidate = node.getAttribute('aria-label');
		if (candidate) {
			candidate = text.sanitize(candidate).trim();
			if (candidate) {
				return candidate;
			}
		}

		return null;
	};

	/*global aria, lookupTables, axe */

	/**
  * Check if a given role is valid
  * @param  {String}  role The role to check
  * @return {Boolean}
  */
	aria.isValidRole = function (role) {
		'use strict';

		if (lookupTables.role[role]) {
			return true;
		}

		return false;
	};

	/**
  * Get the roles that get name from contents
  * @return {Array}           Array of roles that match the type
  */
	aria.getRolesWithNameFromContents = function () {
		return Object.keys(lookupTables.role).filter(function (r) {
			return lookupTables.role[r].nameFrom && lookupTables.role[r].nameFrom.indexOf('contents') !== -1;
		});
	};

	/**
  * Get the roles that have a certain "type"
  * @param  {String} roleType The roletype to check
  * @return {Array}           Array of roles that match the type
  */
	aria.getRolesByType = function (roleType) {
		return Object.keys(lookupTables.role).filter(function (r) {
			return lookupTables.role[r].type === roleType;
		});
	};

	/**
  * Get the "type" of role; either widget, composite, abstract, landmark or `null`
  * @param  {String} role The role to check
  * @return {Mixed}       String if a matching role and its type are found, otherwise `null`
  */
	aria.getRoleType = function (role) {
		var r = lookupTables.role[role];

		return r && r.type || null;
	};

	/**
  * Get the required owned (children) roles for a given role
  * @param  {String} role The role to check
  * @return {Mixed}       Either an Array of required owned elements or `null` if there are none
  */
	aria.requiredOwned = function (role) {
		'use strict';

		var owned = null,
		    roles = lookupTables.role[role];

		if (roles) {
			owned = axe.utils.clone(roles.owned);
		}
		return owned;
	};

	/**
  * Get the required context (parent) roles for a given role
  * @param  {String} role The role to check
  * @return {Mixed}       Either an Array of required context elements or `null` if there are none
  */
	aria.requiredContext = function (role) {
		'use strict';

		var context = null,
		    roles = lookupTables.role[role];

		if (roles) {
			context = axe.utils.clone(roles.context);
		}
		return context;
	};

	/**
  * Get a list of CSS selectors of nodes that have an implicit role
  * @param  {String} role The role to check
  * @return {Mixed}       Either an Array of CSS selectors or `null` if there are none
  */
	aria.implicitNodes = function (role) {
		'use strict';

		var implicit = null,
		    roles = lookupTables.role[role];

		if (roles && roles.implicit) {
			implicit = axe.utils.clone(roles.implicit);
		}
		return implicit;
	};

	/**
  * Get the implicit role for a given node
  * @param  {HTMLElement} node The node to test
  * @return {Mixed}      Either the role or `null` if there is none
  */
	aria.implicitRole = function (node) {
		'use strict';

		var role,
		    r,
		    candidate,
		    roles = lookupTables.role;

		for (role in roles) {
			if (roles.hasOwnProperty(role)) {
				r = roles[role];
				if (r.implicit) {
					for (var index = 0, length = r.implicit.length; index < length; index++) {
						candidate = r.implicit[index];
						if (axe.utils.matchesSelector(node, candidate)) {
							return role;
						}
					}
				}
			}
		}

		return null;
	};

	/*global color */

	/**
  * @constructor
  * @param {number} red
  * @param {number} green
  * @param {number} blue
  * @param {number} alpha
  */
	color.Color = function (red, green, blue, alpha) {
		/** @type {number} */
		this.red = red;

		/** @type {number} */
		this.green = green;

		/** @type {number} */
		this.blue = blue;

		/** @type {number} */
		this.alpha = alpha;

		/**
   * Provide the hex string value for the color
   * @return {string}
   */
		this.toHexString = function () {
			var redString = Math.round(this.red).toString(16);
			var greenString = Math.round(this.green).toString(16);
			var blueString = Math.round(this.blue).toString(16);
			return '#' + (this.red > 15.5 ? redString : '0' + redString) + (this.green > 15.5 ? greenString : '0' + greenString) + (this.blue > 15.5 ? blueString : '0' + blueString);
		};

		var rgbRegex = /^rgb\((\d+), (\d+), (\d+)\)$/;
		var rgbaRegex = /^rgba\((\d+), (\d+), (\d+), (\d*(\.\d+)?)\)/;

		/**
   * Set the color value based on a CSS RGB/RGBA string
   * @param  {string}  rgb  The string value
   */
		this.parseRgbString = function (colorString) {
			// IE can pass transparent as value instead of rgba
			if (colorString === 'transparent') {
				this.red = 0;
				this.green = 0;
				this.blue = 0;
				this.alpha = 0;
				return;
			}
			var match = colorString.match(rgbRegex);

			if (match) {
				this.red = parseInt(match[1], 10);
				this.green = parseInt(match[2], 10);
				this.blue = parseInt(match[3], 10);
				this.alpha = 1;
				return;
			}

			match = colorString.match(rgbaRegex);
			if (match) {
				this.red = parseInt(match[1], 10);
				this.green = parseInt(match[2], 10);
				this.blue = parseInt(match[3], 10);
				this.alpha = parseFloat(match[4]);
				return;
			}
		};

		/**
   * Get the relative luminance value
   * using algorithm from http://www.w3.org/WAI/GL/wiki/Relative_luminance
   * @return {number} The luminance value, ranges from 0 to 1
   */
		this.getRelativeLuminance = function () {
			var rSRGB = this.red / 255;
			var gSRGB = this.green / 255;
			var bSRGB = this.blue / 255;

			var r = rSRGB <= 0.03928 ? rSRGB / 12.92 : Math.pow((rSRGB + 0.055) / 1.055, 2.4);
			var g = gSRGB <= 0.03928 ? gSRGB / 12.92 : Math.pow((gSRGB + 0.055) / 1.055, 2.4);
			var b = bSRGB <= 0.03928 ? bSRGB / 12.92 : Math.pow((bSRGB + 0.055) / 1.055, 2.4);

			return 0.2126 * r + 0.7152 * g + 0.0722 * b;
		};
	};

	/**
  * Combine the two given color according to alpha blending.
  * @param {Color} fgColor
  * @param {Color} bgColor
  * @return {Color}
  */
	color.flattenColors = function (fgColor, bgColor) {
		var alpha = fgColor.alpha;
		var r = (1 - alpha) * bgColor.red + alpha * fgColor.red;
		var g = (1 - alpha) * bgColor.green + alpha * fgColor.green;
		var b = (1 - alpha) * bgColor.blue + alpha * fgColor.blue;
		var a = fgColor.alpha + bgColor.alpha * (1 - fgColor.alpha);

		return new color.Color(r, g, b, a);
	};

	/**
  * Get the contrast of two colors
  * @param  {Color}  bgcolor  Background color
  * @param  {Color}  fgcolor  Foreground color
  * @return {number} The contrast ratio
  */
	color.getContrast = function (bgColor, fgColor) {
		if (!fgColor || !bgColor) {
			return null;
		}

		if (fgColor.alpha < 1) {
			fgColor = color.flattenColors(fgColor, bgColor);
		}

		var bL = bgColor.getRelativeLuminance();
		var fL = fgColor.getRelativeLuminance();

		return (Math.max(fL, bL) + 0.05) / (Math.min(fL, bL) + 0.05);
	};

	/**
  * Check whether certain text properties meet WCAG contrast rules
  * @param  {Color}  bgcolor  Background color
  * @param  {Color}  fgcolor  Foreground color
  * @param  {number}  fontSize  Font size of text, in pixels
  * @param  {boolean}  isBold  Whether the text is bold
  * @return {{isValid: boolean, contrastRatio: number}}
  */
	color.hasValidContrastRatio = function (bg, fg, fontSize, isBold) {
		var contrast = color.getContrast(bg, fg);
		var isSmallFont = isBold && Math.ceil(fontSize * 72) / 96 < 14 || !isBold && Math.ceil(fontSize * 72) / 96 < 18;

		return {
			isValid: isSmallFont && contrast >= 4.5 || !isSmallFont && contrast >= 3,
			contrastRatio: contrast
		};
	};

	/*global color */

	function _getFonts(style) {
		return style.getPropertyValue('font-family').split(/[,;]/g).map(function (font) {
			return font.trim().toLowerCase();
		});
	}

	function elementIsDistinct(node, ancestorNode) {
		var nodeStyle = window.getComputedStyle(node);

		// Check if the link has a background
		if (nodeStyle.getPropertyValue('background-image') !== 'none') {
			return true;
		}

		// Check if the link has a border or outline
		var hasBorder = ['border-bottom', 'border-top', 'outline'].reduce(function (result, edge) {

			var borderClr = new color.Color();
			borderClr.parseRgbString(nodeStyle.getPropertyValue(edge + '-color'));

			// Check if a border/outline was specified
			return result ||
			// or if the current border edge / outline
			nodeStyle.getPropertyValue(edge + '-style') !== 'none' && parseFloat(nodeStyle.getPropertyValue(edge + '-width')) > 0 && borderClr.alpha !== 0;
		}, false);

		if (hasBorder) {
			return true;
		}

		var parentStyle = window.getComputedStyle(ancestorNode);
		// Compare fonts
		if (_getFonts(nodeStyle)[0] !== _getFonts(parentStyle)[0]) {
			return true;
		}

		var hasStyle = ['text-decoration', 'font-weight', 'font-style', 'font-size'].reduce(function (result, cssProp) {
			return result || nodeStyle.getPropertyValue(cssProp) !== parentStyle.getPropertyValue(cssProp);
		}, false);

		return hasStyle;
	}

	color.elementIsDistinct = elementIsDistinct;
	/*global dom, color */
	/* jshint maxstatements: 34, maxcomplexity: 15 */
	//TODO dsturley: too complex, needs refactor!!

	var graphicNodeNames = ['IMG', 'CANVAS', 'OBJECT', 'IFRAME', 'VIDEO', 'SVG'];

	/**
  * Returns the non-alpha-blended background color of a node, null if it's an image
  * @param {Element} node
  * @return {Color}
  */
	function getBackgroundForSingleNode(node) {
		var bgColor, bgColorString, opacity;
		var nodeStyle = window.getComputedStyle(node);
		var nodeName = node.nodeName.toUpperCase();

		if (graphicNodeNames.indexOf(nodeName) !== -1 || nodeStyle.getPropertyValue('background-image') !== 'none') {
			return null;
		}

		bgColorString = nodeStyle.getPropertyValue('background-color');
		//Firefox exposes unspecified background as 'transparent' rather than rgba(0,0,0,0)
		if (bgColorString === 'transparent') {
			bgColor = new color.Color(0, 0, 0, 0);
		} else {
			bgColor = new color.Color();
			bgColor.parseRgbString(bgColorString);
		}

		opacity = nodeStyle.getPropertyValue('opacity');
		bgColor.alpha = bgColor.alpha * opacity;

		return bgColor;
	}

	/**
  * Determines whether an element has a fully opaque background, whether solid color or an image
  * @param {Element} node
  * @return {Boolean} false if the background is transparent, true otherwise
  */
	dom.isOpaque = function (node) {
		var bgColor = getBackgroundForSingleNode(node);
		if (bgColor === null || bgColor.alpha === 1) {
			return true;
		}
		return false;
	};

	/**
  * Returns the elements that are visually "above" this one in z-index order where
  * supported at the position given inside the top-left corner of the provided
  * rectangle. Where not supported (IE < 10), returns the DOM parents.
  * @param {Element} node
  * @param {DOMRect} rect rectangle containing dimensions to consider
  * @return {Array} array of elements
  */
	var getVisualParents = function getVisualParents(node, rect) {
		var visualParents, thisIndex, posVal;
		var parents = [];
		var currentNode = node;
		var nodeStyle = window.getComputedStyle(currentNode);

		if (dom.supportsElementsFromPoint(document)) {
			visualParents = dom.elementsFromPoint(document, Math.ceil(rect.left + 1), Math.ceil(rect.top + 1));
			thisIndex = visualParents.indexOf(node);

			// if the element is not present; then something is obscuring it thus making calculation impossible
			if (thisIndex === -1) {
				return null;
			} else if (visualParents && thisIndex < visualParents.length - 1) {
				return visualParents.slice(thisIndex + 1);
			}
		}

		while (currentNode !== null) {
			// If the element is positioned, we can't rely on DOM order to find visual parents
			posVal = nodeStyle.getPropertyValue('position');
			if (posVal !== 'static') {
				return null;
			}
			currentNode = currentNode.parentElement;
			if (currentNode !== null) {
				nodeStyle = window.getComputedStyle(currentNode);
				if (parseInt(nodeStyle.getPropertyValue('height'), 10) !== 0) {
					parents.push(currentNode);
				}
			}
		}

		return parents;
	};

	/**
  * Returns the flattened background color of an element, or null if it can't be determined because
  * there is no opaque ancestor element visually containing it, or because background images are used.
  * @param {Element} node
  * @param {Array} bgNodes array to which all encountered nodes should be appended
  * @param {Boolean} noScroll (default false)
  * @return {Color}
  */
	//TODO dsturley; why is this passing `bgNodes`?
	color.getBackgroundColor = function (node, bgNodes, noScroll) {
		var parent, parentColor;
		var bgColor = getBackgroundForSingleNode(node);

		if (bgNodes && (bgColor === null || bgColor.alpha !== 0)) {
			bgNodes.push(node);
		}
		if (bgColor === null || bgColor.alpha === 1) {
			return bgColor;
		}

		if (noScroll !== true) {
			node.scrollIntoView();
		}

		var rect = node.getBoundingClientRect();
		var currentNode = node;
		var colorStack = [{
			color: bgColor,
			node: node
		}];
		var parents = getVisualParents(currentNode, rect);

		if (!parents) {
			return null;
		}

		while (bgColor.alpha !== 1) {
			parent = parents.shift();

			if (!parent && currentNode.tagName !== 'HTML') {
				return null;

				//Assume white if top level is not specified
			} else if (!parent && currentNode.tagName === 'HTML') {
				parentColor = new color.Color(255, 255, 255, 1);
			} else {

				if (!dom.visuallyContains(node, parent)) {
					return null;
				}

				parentColor = getBackgroundForSingleNode(parent);
				if (bgNodes && (parentColor === null || parentColor.alpha !== 0)) {
					bgNodes.push(parent);
				}
				if (parentColor === null) {
					return null;
				}
			}
			currentNode = parent;
			bgColor = parentColor;
			colorStack.push({
				color: bgColor,
				node: currentNode
			});
		}

		var currColorNode = colorStack.pop();
		var flattenedColor = currColorNode.color;

		while ((currColorNode = colorStack.pop()) !== undefined) {
			flattenedColor = color.flattenColors(currColorNode.color, flattenedColor);
		}

		return flattenedColor;
	};

	/*global color */

	/**
  * Returns the flattened foreground color of an element, or null if it can't be determined because
  * of transparency
  * @param {Element} node
  * @param {Boolean} noScroll (default false)
  * @return {Color}
  */
	color.getForegroundColor = function (node, noScroll) {
		var nodeStyle = window.getComputedStyle(node);

		var fgColor = new color.Color();
		fgColor.parseRgbString(nodeStyle.getPropertyValue('color'));
		var opacity = nodeStyle.getPropertyValue('opacity');
		fgColor.alpha = fgColor.alpha * opacity;
		if (fgColor.alpha === 1) {
			return fgColor;
		}

		var bgColor = color.getBackgroundColor(node, [], noScroll);
		if (bgColor === null) {
			return null;
		}

		return color.flattenColors(fgColor, bgColor);
	};

	/* global dom */

	/**
  * Returns true if the browser supports one of the methods to get elements from point
  * @param {Document} doc The HTML document
  * @return {Boolean}
  */
	dom.supportsElementsFromPoint = function (doc) {
		var element = doc.createElement('x');
		element.style.cssText = 'pointer-events:auto';
		return element.style.pointerEvents === 'auto' || !!doc.msElementsFromPoint;
	};

	/**
  * Returns the elements at a particular point in the viewport, in z-index order
  * @param {Document} doc The HTML document
  * @param {Element} x The x coordinate, as an integer
  * @param {Element} y The y coordinate, as an integer
  * @return {Array} Array of Elements
  */
	dom.elementsFromPoint = function (doc, x, y) {
		var elements = [],
		    previousPointerEvents = [],
		    current,
		    i,
		    d;

		if (doc.msElementsFromPoint) {
			var nl = doc.msElementsFromPoint(x, y);
			return nl ? Array.prototype.slice.call(nl) : null;
		}

		// get all elements via elementFromPoint, and remove them from hit-testing in order
		while ((current = doc.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current !== null) {

			// push the element and its current style
			elements.push(current);

			previousPointerEvents.push({
				value: current.style.getPropertyValue('pointer-events'),
				priority: current.style.getPropertyPriority('pointer-events')
			});

			// add "pointer-events: none", to get to the underlying element
			current.style.setProperty('pointer-events', 'none', 'important');

			if (dom.isOpaque(current)) {
				break;
			}
		}

		// restore the previous pointer-events values
		for (i = previousPointerEvents.length; !!(d = previousPointerEvents[--i]);) {
			elements[i].style.setProperty('pointer-events', d.value ? d.value : '', d.priority);
		}

		// return our results
		return elements;
	};

	/*global dom, axe */
	/**
  * recusively walk up the DOM, checking for a node which matches a selector
  *
  * **WARNING:** this should be used sparingly, as it's not even close to being performant
  *
  * @param {HTMLElement|String} element The starting HTMLElement
  * @param {String} selector The selector for the HTMLElement
  * @return {HTMLElement|null} Either the matching HTMLElement or `null` if there was no match
  */
	dom.findUp = function (element, target) {
		'use strict';
		/*jslint browser:true*/

		var parent,
		    matches = document.querySelectorAll(target),
		    length = matches.length;

		if (!length) {
			return null;
		}

		matches = axe.utils.toArray(matches);

		parent = element.parentNode;
		// recrusively walk up the DOM, checking each parent node
		while (parent && matches.indexOf(parent) === -1) {
			parent = parent.parentNode;
		}

		return parent;
	};

	/*global dom */

	dom.getElementByReference = function (node, attr) {
		'use strict';

		var candidate,
		    fragment = node.getAttribute(attr),
		    doc = document;

		if (fragment && fragment.charAt(0) === '#') {
			fragment = fragment.substring(1);

			candidate = doc.getElementById(fragment);
			if (candidate) {
				return candidate;
			}

			candidate = doc.getElementsByName(fragment);
			if (candidate.length) {
				return candidate[0];
			}
		}

		return null;
	};
	/*global dom */
	/**
  * Get the coordinates of the element passed into the function relative to the document
  *
  * #### Returns
  *
  * Returns a `Object` with the following properties, which
  * each hold a value representing the pixels for each of the
  * respective coordinates:
  *
  * - `top`
  * - `right`
  * - `bottom`
  * - `left`
  * - `width`
  * - `height`
  *
  * @param {HTMLElement} el The HTMLElement
  */
	dom.getElementCoordinates = function (element) {
		'use strict';

		var scrollOffset = dom.getScrollOffset(document),
		    xOffset = scrollOffset.left,
		    yOffset = scrollOffset.top,
		    coords = element.getBoundingClientRect();

		return {
			top: coords.top + yOffset,
			right: coords.right + xOffset,
			bottom: coords.bottom + yOffset,
			left: coords.left + xOffset,

			width: coords.right - coords.left,
			height: coords.bottom - coords.top
		};
	};

	/*global dom */
	/**
  * Get the scroll offset of the document passed in
  *
  * @param {Document} element The element to evaluate, defaults to document
  * @return {Object} Contains the attributes `x` and `y` which contain the scroll offsets
  */
	dom.getScrollOffset = function (element) {
		'use strict';

		if (!element.nodeType && element.document) {
			element = element.document;
		}

		// 9 === Node.DOCUMENT_NODE
		if (element.nodeType === 9) {
			var docElement = element.documentElement,
			    body = element.body;

			return {
				left: docElement && docElement.scrollLeft || body && body.scrollLeft || 0,
				top: docElement && docElement.scrollTop || body && body.scrollTop || 0
			};
		}

		return {
			left: element.scrollLeft,
			top: element.scrollTop
		};
	};
	/*global dom */
	/**
  * Gets the width and height of the viewport; used to calculate the right and bottom boundaries of the viewable area.
  *
  * @api private
  * @param  {Object}  window The `window` object that should be measured
  * @return {Object}  Object with the `width` and `height` of the viewport
  */
	dom.getViewportSize = function (win) {
		'use strict';

		var body,
		    doc = win.document,
		    docElement = doc.documentElement;

		if (win.innerWidth) {
			return {
				width: win.innerWidth,
				height: win.innerHeight
			};
		}

		if (docElement) {
			return {
				width: docElement.clientWidth,
				height: docElement.clientHeight
			};
		}

		body = doc.body;

		return {
			width: body.clientWidth,
			height: body.clientHeight
		};
	};
	/*global dom, axe */

	/**
  * Get elements referenced via a space-separated token attribute; it will insert `null` for any Element that is not found
  * @param  {HTMLElement} node
  * @param  {String} attr The name of attribute
  * @return {Array}      Array of elements (or `null` if not found)
  */
	dom.idrefs = function (node, attr) {
		'use strict';

		var index,
		    length,
		    doc = document,
		    result = [],
		    idrefs = node.getAttribute(attr);

		if (idrefs) {
			idrefs = axe.utils.tokenList(idrefs);
			for (index = 0, length = idrefs.length; index < length; index++) {
				result.push(doc.getElementById(idrefs[index]));
			}
		}

		return result;
	};
	/*global dom */
	/* jshint maxcomplexity: 20 */
	/**
  * Determines if an element is focusable
  * @param {HTMLelement} element The HTMLelement
  * @return {Boolean} The element's focusability status
  */

	dom.isFocusable = function (el) {
		'use strict';

		if (!el || el.disabled || !dom.isVisible(el) && el.nodeName.toUpperCase() !== 'AREA') {
			return false;
		}

		switch (el.nodeName.toUpperCase()) {
			case 'A':
			case 'AREA':
				if (el.href) {
					return true;
				}
				break;
			case 'INPUT':
				return el.type !== 'hidden';
			case 'TEXTAREA':
			case 'SELECT':
			case 'DETAILS':
			case 'BUTTON':
				return true;
		}

		// check if the tabindex is specified and a parseable number
		var tabindex = el.getAttribute('tabindex');
		if (tabindex && !isNaN(parseInt(tabindex, 10))) {
			return true;
		}

		return false;
	};

	/*global dom */
	dom.isHTML5 = function (doc) {
		var node = doc.doctype;
		if (node === null) {
			return false;
		}
		return node.name === 'html' && !node.publicId && !node.systemId;
	};
	/* global axe, dom, window */

	function walkDomNode(node, functor) {
		'use strict';

		var shouldWalk = functor(node);
		node = node.firstChild;
		while (node) {
			if (shouldWalk !== false) {
				walkDomNode(node, functor);
			}
			node = node.nextSibling;
		}
	}

	var blockLike = ['block', 'list-item', 'table', 'flex', 'grid', 'inline-block'];
	function isBlock(elm) {
		'use strict';

		var display = window.getComputedStyle(elm).getPropertyValue('display');
		return blockLike.indexOf(display) !== -1 || display.substr(0, 6) === 'table-';
	}

	dom.isInTextBlock = function isInTextBlock(node) {
		// jshint maxcomplexity: 15
		'use strict';
		// Ignore if the link is a block

		if (isBlock(node)) {
			return false;
		}

		// Find the closest parent
		var parentBlock = node.parentNode;
		while (parentBlock.nodeType === 1 && !isBlock(parentBlock)) {
			parentBlock = parentBlock.parentNode;
		}

		// Find all the text part of the parent block not in a link, and all the text in a link
		var parentText = '';
		var linkText = '';
		var inBrBlock = 0;

		// We want to ignore hidden text, and if br / hr is used, only use the section of the parent
		// that has the link we're looking at
		walkDomNode(parentBlock, function (currNode) {
			// We're already passed it, skip everything else
			if (inBrBlock === 2) {
				return false;
			}

			if (currNode.nodeType === 3) {
				// Add the text to the parent
				parentText += currNode.nodeValue;
			}
			// Ignore any node that's not an element (or text as above)
			if (currNode.nodeType !== 1) {
				return;
			}

			var nodeName = (currNode.nodeName || '').toUpperCase();
			// BR and HR elements break the line
			if (['BR', 'HR'].indexOf(nodeName) !== -1) {
				if (inBrBlock === 0) {
					parentText = '';
					linkText = '';
				} else {
					inBrBlock = 2;
				}

				// Don't walk nodes with content not displayed on screen.
			} else if (currNode.style.display === 'none' || currNode.style.overflow === 'hidden' || ['', null, 'none'].indexOf(currNode.style.float) === -1 || ['', null, 'relative'].indexOf(currNode.style.position) === -1) {
				return false;

				// Don't walk links, we're only interested in what's not in them.
			} else if (nodeName === 'A' && currNode.href || (currNode.getAttribute('role') || '').toLowerCase() === 'link') {
				if (currNode === node) {
					inBrBlock = 1;
				}
				// Grab all the text from this element, but don't walk down it's children
				linkText += currNode.textContent;
				return false;
			}
		});

		parentText = axe.commons.text.sanitize(parentText);
		linkText = axe.commons.text.sanitize(linkText);

		return parentText.length > linkText.length;
	};

	/*global dom */
	dom.isNode = function (candidate) {
		'use strict';

		return candidate instanceof Node;
	};

	/*global dom */

	dom.isOffscreen = function (element) {
		'use strict';

		var leftBoundary,
		    docElement = document.documentElement,
		    dir = window.getComputedStyle(document.body || docElement).getPropertyValue('direction'),
		    coords = dom.getElementCoordinates(element);

		// bottom edge beyond
		if (coords.bottom < 0) {
			return true;
		}

		if (dir === 'ltr') {
			if (coords.right < 0) {
				return true;
			}
		} else {

			leftBoundary = Math.max(docElement.scrollWidth, dom.getViewportSize(window).width);
			if (coords.left > leftBoundary) {
				return true;
			}
		}

		return false;
	};

	/*global dom */
	/*jshint maxcomplexity: 11 */

	/**
  * Determines if an element is hidden with the clip rect technique
  * @param  {String}  clip Computed property value of clip
  * @return {Boolean}
  */
	function isClipped(clip) {
		'use strict';

		var matches = clip.match(/rect\s*\(([0-9]+)px,?\s*([0-9]+)px,?\s*([0-9]+)px,?\s*([0-9]+)px\s*\)/);
		if (matches && matches.length === 5) {
			return matches[3] - matches[1] <= 0 && matches[2] - matches[4] <= 0;
		}

		return false;
	}

	/**
  * Determine whether an element is visible
  *
  * @param {HTMLElement} el The HTMLElement
  * @param {Boolean} screenReader When provided, will evaluate visibility from the perspective of a screen reader
  * @return {Boolean} The element's visibilty status
  */
	dom.isVisible = function (el, screenReader, recursed) {
		'use strict';

		var style,
		    nodeName = el.nodeName.toUpperCase(),
		    parent = el.parentNode;

		// 9 === Node.DOCUMENT
		if (el.nodeType === 9) {
			return true;
		}

		style = window.getComputedStyle(el, null);
		if (style === null) {
			return false;
		}

		if (style.getPropertyValue('display') === 'none' || nodeName.toUpperCase() === 'STYLE' || nodeName.toUpperCase() === 'SCRIPT' || !screenReader && isClipped(style.getPropertyValue('clip')) || !recursed && (
		// visibility is only accurate on the first element
		style.getPropertyValue('visibility') === 'hidden' ||
		// position does not matter if it was already calculated
		!screenReader && dom.isOffscreen(el)) || screenReader && el.getAttribute('aria-hidden') === 'true') {

			return false;
		}

		if (parent) {
			return dom.isVisible(parent, screenReader, true);
		}

		return false;
	};

	/*global dom */
	/*jshint maxcomplexity: 20 */

	/**
  * Check if an element is an inherently visual element
  * @param  {object}  candidate The node to check
  * @return {Boolean}
  */
	dom.isVisualContent = function (candidate) {
		'use strict';

		switch (candidate.tagName.toUpperCase()) {
			case 'IMG':
			case 'IFRAME':
			case 'OBJECT':
			case 'VIDEO':
			case 'AUDIO':
			case 'CANVAS':
			case 'SVG':
			case 'MATH':
			case 'BUTTON':
			case 'SELECT':
			case 'TEXTAREA':
			case 'KEYGEN':
			case 'PROGRESS':
			case 'METER':
				return true;
			case 'INPUT':
				return candidate.type !== 'hidden';
			default:
				return false;
		}
	};

	/* global dom */
	/* jshint maxcomplexity: 11 */

	/**
  * Checks whether a parent element visually contains its child, either directly or via scrolling.
  * Assumes that |parent| is an ancestor of |node|.
  * @param {Element} node
  * @param {Element} parent
  * @return {boolean} True if node is visually contained within parent
  */
	dom.visuallyContains = function (node, parent) {
		var rectBound = node.getBoundingClientRect();
		var margin = 0.01;
		var rect = {
			top: rectBound.top + margin,
			bottom: rectBound.bottom - margin,
			left: rectBound.left + margin,
			right: rectBound.right - margin
		};
		var parentRect = parent.getBoundingClientRect();
		var parentTop = parentRect.top;
		var parentLeft = parentRect.left;
		var parentScrollArea = {
			top: parentTop - parent.scrollTop,
			bottom: parentTop - parent.scrollTop + parent.scrollHeight,
			left: parentLeft - parent.scrollLeft,
			right: parentLeft - parent.scrollLeft + parent.scrollWidth
		};

		//In theory, we should just be able to look at the scroll area as a superset of the parentRect,
		//but that's not true in Firefox
		if (rect.left < parentScrollArea.left && rect.left < parentRect.left || rect.top < parentScrollArea.top && rect.top < parentRect.top || rect.right > parentScrollArea.right && rect.right > parentRect.right || rect.bottom > parentScrollArea.bottom && rect.bottom > parentRect.bottom) {
			return false;
		}

		var style = window.getComputedStyle(parent);

		if (rect.right > parentRect.right || rect.bottom > parentRect.bottom) {
			return style.overflow === 'scroll' || style.overflow === 'auto' || style.overflow === 'hidden' || parent instanceof HTMLBodyElement || parent instanceof HTMLHtmlElement;
		}

		return true;
	};

	/* global dom */
	/* jshint maxcomplexity: 11 */

	/**
  * Checks whether a parent element visually overlaps a rectangle, either directly or via scrolling.
  * @param {DOMRect} rect
  * @param {Element} parent
  * @return {boolean} True if rect is visually contained within parent
  */
	dom.visuallyOverlaps = function (rect, parent) {
		var parentRect = parent.getBoundingClientRect();
		var parentTop = parentRect.top;
		var parentLeft = parentRect.left;
		var parentScrollArea = {
			top: parentTop - parent.scrollTop,
			bottom: parentTop - parent.scrollTop + parent.scrollHeight,
			left: parentLeft - parent.scrollLeft,
			right: parentLeft - parent.scrollLeft + parent.scrollWidth
		};

		//In theory, we should just be able to look at the scroll area as a superset of the parentRect,
		//but that's not true in Firefox
		if (rect.left > parentScrollArea.right && rect.left > parentRect.right || rect.top > parentScrollArea.bottom && rect.top > parentRect.bottom || rect.right < parentScrollArea.left && rect.right < parentRect.left || rect.bottom < parentScrollArea.top && rect.bottom < parentRect.top) {
			return false;
		}

		var style = window.getComputedStyle(parent);

		if (rect.left > parentRect.right || rect.top > parentRect.bottom) {
			return style.overflow === 'scroll' || style.overflow === 'auto' || parent instanceof HTMLBodyElement || parent instanceof HTMLHtmlElement;
		}

		return true;
	};

	/*global table, dom */

	/**
  * Get the x, y coordinates of a table cell; normalized for rowspan and colspan
  * @param  {HTMLTableCelLElement} cell The table cell of which to get the position
  * @return {Object}      Object with `x` and `y` properties of the coordinates
  */
	table.getCellPosition = function (cell) {

		var tbl = table.toArray(dom.findUp(cell, 'table')),
		    index;

		for (var rowIndex = 0; rowIndex < tbl.length; rowIndex++) {
			if (tbl[rowIndex]) {
				index = tbl[rowIndex].indexOf(cell);
				if (index !== -1) {
					return {
						x: index,
						y: rowIndex
					};
				}
			}
		}
	};
	/*global table */

	/**
  * Get any associated table headers for a `HTMLTableCellElement`
  * @param  {HTMLTableCellElement} cell The cell of which to get headers
  * @return {Array}      Array of headers associated to the table cell
  */
	table.getHeaders = function (cell) {

		if (cell.hasAttribute('headers')) {
			return commons.dom.idrefs(cell, 'headers');
		}

		var headers = [],
		    currentCell,
		    tbl = commons.table.toArray(commons.dom.findUp(cell, 'table')),
		    position = commons.table.getCellPosition(cell);

		//
		for (var x = position.x - 1; x >= 0; x--) {
			currentCell = tbl[position.y][x];

			if (commons.table.isRowHeader(currentCell)) {
				headers.unshift(currentCell);
			}
		}

		for (var y = position.y - 1; y >= 0; y--) {
			currentCell = tbl[y][position.x];

			if (currentCell && commons.table.isColumnHeader(currentCell)) {
				headers.unshift(currentCell);
			}
		}

		return headers;
	};
	/*global table, dom */

	/**
  * Determine if a `HTMLTableCellElement` is a column header
  * @param  {HTMLTableCellElement}  node The table cell to test
  * @return {Boolean}
  */
	table.isColumnHeader = function (node) {

		var scope = node.getAttribute('scope');
		if (scope === 'col' || node.getAttribute('role') === 'columnheader') {
			return true;
		} else if (scope || node.nodeName.toUpperCase() !== 'TH') {
			return false;
		}

		var currentCell,
		    position = table.getCellPosition(node),
		    tbl = table.toArray(dom.findUp(node, 'table')),
		    cells = tbl[position.y];

		for (var cellIndex = 0, cellLength = cells.length; cellIndex < cellLength; cellIndex++) {
			currentCell = cells[cellIndex];
			if (currentCell !== node) {
				if (table.isDataCell(currentCell)) {
					return false;
				}
			}
		}

		return true;
	};
	/*global table */

	/**
  * Determine if a `HTMLTableCellElement` is a data cell
  * @param  {HTMLTableCellElement}  node The table cell to test
  * @return {Boolean}
  */
	table.isDataCell = function (cell) {
		// @see http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#empty-cell
		if (!cell.children.length && !cell.textContent.trim()) {
			return false;
		}
		return cell.nodeName.toUpperCase() === 'TD';
	};
	/*global table, dom */
	/*jshint maxstatements: 70, maxcomplexity: 40 */

	/**
  * Determines whether a table is a data table
  * @param  {HTMLTableElement}  node The table to test
  * @return {Boolean}
  * @see http://asurkov.blogspot.co.uk/2011/10/data-vs-layout-table.html
  */
	table.isDataTable = function (node) {

		var role = node.getAttribute('role');

		// The element is not focusable and has role=presentation
		if ((role === 'presentation' || role === 'none') && !dom.isFocusable(node)) {
			return false;
		}

		// Table inside editable area is data table always since the table structure is crucial for table editing
		if (node.getAttribute('contenteditable') === 'true' || dom.findUp(node, '[contenteditable="true"]')) {
			return true;
		}

		// Table having ARIA table related role is data table
		if (role === 'grid' || role === 'treegrid' || role === 'table') {
			return true;
		}

		// Table having ARIA landmark role is data table
		if (commons.aria.getRoleType(role) === 'landmark') {
			return true;
		}

		// Table having datatable="0" attribute is layout table
		if (node.getAttribute('datatable') === '0') {
			return false;
		}

		// Table having summary attribute is data table
		if (node.getAttribute('summary')) {
			return true;
		}

		// Table having legitimate data table structures is data table
		if (node.tHead || node.tFoot || node.caption) {
			return true;
		}
		// colgroup / col - colgroup is magically generated
		for (var childIndex = 0, childLength = node.children.length; childIndex < childLength; childIndex++) {
			if (node.children[childIndex].nodeName.toUpperCase() === 'COLGROUP') {
				return true;
			}
		}

		var cells = 0;
		var rowLength = node.rows.length;
		var row, cell;
		var hasBorder = false;
		for (var rowIndex = 0; rowIndex < rowLength; rowIndex++) {
			row = node.rows[rowIndex];
			for (var cellIndex = 0, cellLength = row.cells.length; cellIndex < cellLength; cellIndex++) {
				cell = row.cells[cellIndex];
				if (cell.nodeName.toUpperCase() === 'TH') {
					return true;
				}
				if (!hasBorder && (cell.offsetWidth !== cell.clientWidth || cell.offsetHeight !== cell.clientHeight)) {
					hasBorder = true;
				}
				if (cell.getAttribute('scope') || cell.getAttribute('headers') || cell.getAttribute('abbr')) {
					return true;
				}
				if (['columnheader', 'rowheader'].indexOf(cell.getAttribute('role')) !== -1) {
					return true;
				}
				// abbr element as a single child element of table cell
				if (cell.children.length === 1 && cell.children[0].nodeName.toUpperCase() === 'ABBR') {
					return true;
				}
				cells++;
			}
		}

		// Table having nested table is layout table
		if (node.getElementsByTagName('table').length) {
			return false;
		}

		// Table having only one row or column is layout table (row)
		if (rowLength < 2) {
			return false;
		}

		// Table having only one row or column is layout table (column)
		var sampleRow = node.rows[Math.ceil(rowLength / 2)];
		if (sampleRow.cells.length === 1 && sampleRow.cells[0].colSpan === 1) {
			return false;
		}

		// Table having many columns (>= 5) is data table
		if (sampleRow.cells.length >= 5) {
			return true;
		}

		// Table having borders around cells is data table
		if (hasBorder) {
			return true;
		}

		// Table having differently colored rows is data table
		var bgColor, bgImage;
		for (rowIndex = 0; rowIndex < rowLength; rowIndex++) {
			row = node.rows[rowIndex];
			if (bgColor && bgColor !== window.getComputedStyle(row).getPropertyValue('background-color')) {
				return true;
			} else {
				bgColor = window.getComputedStyle(row).getPropertyValue('background-color');
			}
			if (bgImage && bgImage !== window.getComputedStyle(row).getPropertyValue('background-image')) {
				return true;
			} else {
				bgImage = window.getComputedStyle(row).getPropertyValue('background-image');
			}
		}

		// Table having many rows (>= 20) is data table
		if (rowLength >= 20) {
			return true;
		}

		// Wide table (more than 95% of the document width) is layout table
		if (dom.getElementCoordinates(node).width > dom.getViewportSize(window).width * 0.95) {
			return false;
		}

		// Table having small amount of cells (<= 10) is layout table
		if (cells < 10) {
			return false;
		}

		// Table containing embed, object, applet of iframe elements (typical advertisements elements) is layout table
		if (node.querySelector('object, embed, iframe, applet')) {
			return false;
		}

		// Otherwise it's data table
		return true;
	};

	/*global table, axe */

	/**
  * Determine if a `HTMLTableCellElement` is a header
  * @param  {HTMLTableCellElement}  node The table cell to test
  * @return {Boolean}
  */
	table.isHeader = function (cell) {
		if (table.isColumnHeader(cell) || table.isRowHeader(cell)) {
			return true;
		}

		if (cell.id) {
			return !!document.querySelector('[headers~="' + axe.utils.escapeSelector(cell.id) + '"]');
		}

		return false;
	};

	/*global table, dom */

	/**
  * Determine if a `HTMLTableCellElement` is a row header
  * @param  {HTMLTableCellElement}  node The table cell to test
  * @return {Boolean}
  */
	table.isRowHeader = function (node) {

		var scope = node.getAttribute('scope');
		if (scope === 'row' || node.getAttribute('role') === 'rowheader') {
			return true;
		} else if (scope || node.nodeName.toUpperCase() !== 'TH') {
			return false;
		}

		if (table.isColumnHeader(node)) {
			return false;
		}

		var currentCell,
		    position = table.getCellPosition(node),
		    tbl = table.toArray(dom.findUp(node, 'table'));

		for (var rowIndex = 0, rowLength = tbl.length; rowIndex < rowLength; rowIndex++) {
			currentCell = tbl[rowIndex][position.x];
			if (currentCell !== node) {
				if (table.isDataCell(currentCell)) {
					return false;
				}
			}
		}

		return true;
	};
	/*global table */

	/**
  * Converts a table to an Array, normalized for row and column spans
  * @param  {HTMLTableElement} node The table to convert
  * @return {Array}      Array of rows and cells
  */
	table.toArray = function (node) {
		var table = [];
		var rows = node.rows;
		for (var i = 0, rowLength = rows.length; i < rowLength; i++) {
			var cells = rows[i].cells;
			table[i] = table[i] || [];

			var columnIndex = 0;

			for (var j = 0, cellLength = cells.length; j < cellLength; j++) {
				for (var colSpan = 0; colSpan < cells[j].colSpan; colSpan++) {
					for (var rowSpan = 0; rowSpan < cells[j].rowSpan; rowSpan++) {
						table[i + rowSpan] = table[i + rowSpan] || [];
						while (table[i + rowSpan][columnIndex]) {
							columnIndex++;
						}
						table[i + rowSpan][columnIndex] = cells[j];
					}
					columnIndex++;
				}
			}
		}

		return table;
	};

	/*global text, dom, aria, axe */
	/*jshint maxstatements: 25, maxcomplexity: 19 */

	var defaultButtonValues = {
		submit: 'Submit',
		reset: 'Reset'
	};

	var inputTypes = ['text', 'search', 'tel', 'url', 'email', 'date', 'time', 'number', 'range', 'color'];
	var phrasingElements = ['A', 'EM', 'STRONG', 'SMALL', 'MARK', 'ABBR', 'DFN', 'I', 'B', 'S', 'U', 'CODE', 'VAR', 'SAMP', 'KBD', 'SUP', 'SUB', 'Q', 'CITE', 'SPAN', 'BDO', 'BDI', 'BR', 'WBR', 'INS', 'DEL', 'IMG', 'EMBED', 'OBJECT', 'IFRAME', 'MAP', 'AREA', 'SCRIPT', 'NOSCRIPT', 'RUBY', 'VIDEO', 'AUDIO', 'INPUT', 'TEXTAREA', 'SELECT', 'BUTTON', 'LABEL', 'OUTPUT', 'DATALIST', 'KEYGEN', 'PROGRESS', 'COMMAND', 'CANVAS', 'TIME', 'METER'];

	/**
  * Find a non-ARIA label for an element
  *
  * @param {HTMLElement} element The HTMLElement
  * @return {HTMLElement} The label element, or null if none is found
  */
	function findLabel(element) {
		var ref = null;
		if (element.id) {
			ref = document.querySelector('label[for="' + axe.utils.escapeSelector(element.id) + '"]');
			if (ref) {
				return ref;
			}
		}
		ref = dom.findUp(element, 'label');
		return ref;
	}

	function isButton(element) {
		return ['button', 'reset', 'submit'].indexOf(element.type) !== -1;
	}

	function isInput(element) {
		var nodeName = element.nodeName.toUpperCase();
		return nodeName === 'TEXTAREA' || nodeName === 'SELECT' || nodeName === 'INPUT' && element.type.toLowerCase() !== 'hidden';
	}

	function shouldCheckSubtree(element) {
		return ['BUTTON', 'SUMMARY', 'A'].indexOf(element.nodeName.toUpperCase()) !== -1;
	}

	function shouldNeverCheckSubtree(element) {
		return ['TABLE', 'FIGURE'].indexOf(element.nodeName.toUpperCase()) !== -1;
	}

	/**
  * Calculate value of a form element when treated as a value
  *
  * @param {HTMLElement} element The HTMLElement
  * @return {string} The calculated value
  */
	function formValueText(element) {
		var nodeName = element.nodeName.toUpperCase();
		if (nodeName === 'INPUT') {
			if (!element.hasAttribute('type') || inputTypes.indexOf(element.getAttribute('type').toLowerCase()) !== -1 && element.value) {
				return element.value;
			}
			return '';
		}

		if (nodeName === 'SELECT') {
			var opts = element.options;
			if (opts && opts.length) {
				var returnText = '';
				for (var i = 0; i < opts.length; i++) {
					if (opts[i].selected) {
						returnText += ' ' + opts[i].text;
					}
				}
				return text.sanitize(returnText);
			}
			return '';
		}

		if (nodeName === 'TEXTAREA' && element.value) {
			return element.value;
		}
		return '';
	}

	function checkDescendant(element, nodeName) {
		var candidate = element.querySelector(nodeName.toLowerCase());
		if (candidate) {
			return text.accessibleText(candidate);
		}

		return '';
	}

	/**
  * Determine whether an element can be an embedded control
  *
  * @param {HTMLElement} element The HTMLElement
  * @return {boolean} True if embedded control
  */
	function isEmbeddedControl(e) {
		if (!e) {
			return false;
		}
		switch (e.nodeName.toUpperCase()) {
			case 'SELECT':
			case 'TEXTAREA':
				return true;
			case 'INPUT':
				return !e.hasAttribute('type') || inputTypes.indexOf(e.getAttribute('type').toLowerCase()) !== -1;
			default:
				return false;
		}
	}

	function shouldCheckAlt(element) {
		var nodeName = element.nodeName.toUpperCase();
		return nodeName === 'INPUT' && element.type.toLowerCase() === 'image' || ['IMG', 'APPLET', 'AREA'].indexOf(nodeName) !== -1;
	}

	function nonEmptyText(t) {
		return !!text.sanitize(t);
	}

	/**
  * Determine the accessible text of an element, using logic from ARIA:
  * http://www.w3.org/TR/html-aam-1.0/
  * http://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  *
  * @param {HTMLElement} element The HTMLElement
  * @param {Boolean} inLabelledByContext True when in the context of resolving a labelledBy
  * @return {string}
  */
	text.accessibleText = function (element, inLabelledByContext) {
		var accessibleNameComputation;
		var encounteredNodes = [];

		function getInnerText(element, inLabelledByContext, inControlContext) {
			var nodes = element.childNodes;
			var returnText = '';
			var node;

			for (var i = 0; i < nodes.length; i++) {
				node = nodes[i];
				if (node.nodeType === 3) {
					returnText += node.textContent;
				} else if (node.nodeType === 1) {
					if (phrasingElements.indexOf(node.nodeName.toUpperCase()) === -1) {
						returnText += ' ';
					}
					returnText += accessibleNameComputation(nodes[i], inLabelledByContext, inControlContext);
				}
			}

			return returnText;
		}

		function checkNative(element, inLabelledByContext, inControlContext) {
			// jshint maxstatements:30
			var returnText = '';
			var nodeName = element.nodeName.toUpperCase();

			if (shouldCheckSubtree(element)) {
				returnText = getInnerText(element, false, false) || '';
				if (nonEmptyText(returnText)) {
					return returnText;
				}
			}
			if (nodeName === 'FIGURE') {
				returnText = checkDescendant(element, 'figcaption');

				if (nonEmptyText(returnText)) {
					return returnText;
				}
			}

			if (nodeName === 'TABLE') {
				returnText = checkDescendant(element, 'caption');

				if (nonEmptyText(returnText)) {
					return returnText;
				}

				returnText = element.getAttribute('title') || element.getAttribute('summary') || '';

				if (nonEmptyText(returnText)) {
					return returnText;
				}
			}

			if (shouldCheckAlt(element)) {
				return element.getAttribute('alt') || '';
			}

			if (isInput(element) && !inControlContext) {
				if (isButton(element)) {
					return element.value || element.title || defaultButtonValues[element.type] || '';
				}

				var labelElement = findLabel(element);
				if (labelElement) {
					return accessibleNameComputation(labelElement, inLabelledByContext, true);
				}
			}

			return '';
		}

		function checkARIA(element, inLabelledByContext, inControlContext) {

			if (!inLabelledByContext && element.hasAttribute('aria-labelledby')) {
				return text.sanitize(dom.idrefs(element, 'aria-labelledby').map(function (l) {
					if (element === l) {
						encounteredNodes.pop();
					} //let element be encountered twice
					return accessibleNameComputation(l, true, element !== l);
				}).join(' '));
			}

			if (!(inControlContext && isEmbeddedControl(element)) && element.hasAttribute('aria-label')) {
				return text.sanitize(element.getAttribute('aria-label'));
			}

			return '';
		}

		/**
   * Determine the accessible text of an element, using logic from ARIA:
   * http://www.w3.org/TR/accname-aam-1.1/#mapping_additional_nd_name
   *
   * @param {HTMLElement} element The HTMLElement
   * @param {Boolean} inLabelledByContext True when in the context of resolving a labelledBy
   * @param {Boolean} inControlContext True when in the context of textifying a widget
   * @return {string}
   */
		accessibleNameComputation = function accessibleNameComputation(element, inLabelledByContext, inControlContext) {
			'use strict';

			var returnText;
			// If the node was already checked or is null, skip
			if (element === null || encounteredNodes.indexOf(element) !== -1) {
				return '';

				//Step 2a: Skip if the element is hidden, unless part of labelledby
			} else if (!inLabelledByContext && !dom.isVisible(element, true)) {
				return '';
			}

			encounteredNodes.push(element);
			var role = element.getAttribute('role');

			//Step 2b & 2c
			returnText = checkARIA(element, inLabelledByContext, inControlContext);
			if (nonEmptyText(returnText)) {
				return returnText;
			}

			//Step 2d - native attribute or elements
			returnText = checkNative(element, inLabelledByContext, inControlContext);
			if (nonEmptyText(returnText)) {
				return returnText;
			}

			//Step 2e
			if (inControlContext) {
				returnText = formValueText(element);
				if (nonEmptyText(returnText)) {
					return returnText;
				}
			}

			//Step 2f
			if (!shouldNeverCheckSubtree(element) && (!role || aria.getRolesWithNameFromContents().indexOf(role) !== -1)) {

				returnText = getInnerText(element, inLabelledByContext, inControlContext);

				if (nonEmptyText(returnText)) {
					return returnText;
				}
			}

			//Step 2g - if text node, return value (handled in getInnerText)

			//Step 2h
			if (element.hasAttribute('title')) {
				return element.getAttribute('title');
			}

			return '';
		};

		return text.sanitize(accessibleNameComputation(element, inLabelledByContext));
	};

	/*global text, dom, axe, aria */
	/**
  * Gets the visible text of a label for a given input
  * @see http://www.w3.org/WAI/PF/aria/roles#namecalculation
  * @param  {HTMLElement} node The input to test
  * @return {Mixed}      String of visible text, or `null` if no label is found
  */
	text.label = function (node) {
		var ref, candidate;

		candidate = aria.label(node);
		if (candidate) {
			return candidate;
		}

		// explicit label
		if (node.id) {
			ref = document.querySelector('label[for="' + axe.utils.escapeSelector(node.id) + '"]');
			candidate = ref && text.visible(ref, true);
			if (candidate) {
				return candidate;
			}
		}

		ref = dom.findUp(node, 'label');
		candidate = ref && text.visible(ref, true);
		if (candidate) {
			return candidate;
		}

		return null;
	};

	/*global text */
	text.sanitize = function (str) {
		'use strict';

		return str.replace(/\r\n/g, '\n').replace(/\u00A0/g, ' ').replace(/[\s]{2,}/g, ' ').trim();
	};

	/*global text, dom */

	text.visible = function (element, screenReader, noRecursing) {
		'use strict';

		var index,
		    child,
		    nodeValue,
		    childNodes = element.childNodes,
		    length = childNodes.length,
		    result = '';

		for (index = 0; index < length; index++) {
			child = childNodes[index];

			if (child.nodeType === 3) {
				nodeValue = child.nodeValue;
				if (nodeValue && dom.isVisible(element, screenReader)) {
					result += child.nodeValue;
				}
			} else if (!noRecursing) {
				result += text.visible(child, screenReader);
			}
		}

		return text.sanitize(result);
	};

	/*global axe */
	axe.utils.toArray = function (thing) {
		'use strict';

		return Array.prototype.slice.call(thing);
	};
	/*global axe */

	axe.utils.tokenList = function (str) {
		'use strict';

		return str.trim().replace(/\s{2,}/g, ' ').split(' ');
	};
	return commons;
})();
